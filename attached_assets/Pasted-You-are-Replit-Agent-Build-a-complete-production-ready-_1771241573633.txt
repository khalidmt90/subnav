You are Replit Agent. Build a complete, production-ready mobile app and backend API called "Subscriptions Radar" (Ø±Ø§Ø¯Ø§Ø± Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª) â€” a Saudi-market app that automatically detects subscription renewals from Gmail emails and alerts users before charges happen.

CRITICAL RULES BEFORE YOU START:
- Arabic is the DEFAULT language. Every string, label, error, and UI element must be in Arabic first.
- RTL (right-to-left) layout is the default for ALL screens. English is a secondary toggle only.
- App Store safe: read Gmail ONLY via Google OAuth + Gmail API readonly scope. Never touch SMS, iMessage, or WhatsApp.
- Do not skip any screen. All 8 screens listed below are required for MVP.

================================================================================
FOLDER STRUCTURE
================================================================================

/
â”œâ”€â”€ mobile/          <- Expo React Native + TypeScript
â”œâ”€â”€ server/          <- Node.js + TypeScript + Express
â”œâ”€â”€ supabase/        <- SQL migration files
â””â”€â”€ README.md

================================================================================
TECH STACK
================================================================================

MOBILE:
- Expo SDK (latest stable), React Native, TypeScript
- expo-auth-session (Google OAuth)
- expo-notifications (push + local notifications)
- expo-font (load IBM Plex Arabic font)
- @supabase/supabase-js (auth + database client)
- react-native-reanimated (animations)
- @react-navigation/native + stack + bottom-tabs
- AsyncStorage for local preferences
- Custom t('key') i18n function with AR/EN dictionary (no external i18n library needed)

BACKEND:
- Node.js + TypeScript + Express
- googleapis (gmail v1)
- openai (structured JSON output)
- @supabase/supabase-js with SERVICE_ROLE_KEY
- zod for request validation
- Node built-in crypto for AES-256-CBC token encryption

DATABASE: Supabase Postgres with Row Level Security enabled on every table

================================================================================
RTL + ARABIC â€” GLOBAL RULES (apply to every screen and component)
================================================================================

1. On app startup, call I18nManager.forceRTL(true) before any navigation renders.
   Wrap the root Navigator in a View with style={{ flex:1, direction:'rtl' }}.

2. Default language is 'ar'. Store language preference in AsyncStorage under key 'lang'.
   On boot, read AsyncStorage and initialize i18n context accordingly.

3. Font: Load "IBM Plex Arabic" via expo-font. Apply it to all Text components when
   language is 'ar'. For English mode, use the system default sans-serif.

4. All directional icons (chevrons, arrows, back buttons) must flip in RTL.
   Build a helper: const isRTL = language === 'ar'
   Use: <Ionicons name={isRTL ? 'chevron-forward' : 'chevron-back'} /> for back buttons.

5. Currency in Arabic mode: "Ù¤Ù© Ø±ÙŠØ§Ù„" (Arabic-Indic numerals + Ø±ÙŠØ§Ù„ suffix).
   In English mode: "SAR 49".
   Format with: amount.toLocaleString('ar-SA') for Arabic numerals.

6. Dates in Arabic mode: show BOTH Gregorian and Hijri.
   Gregorian: date.toLocaleDateString('ar-SA', { weekday:'long', day:'numeric', month:'long' })
   Hijri: new Intl.DateTimeFormat('ar-SA-u-ca-islamic', { day:'numeric', month:'long', year:'numeric' }).format(date)
   English mode: date.toLocaleDateString('en-US', { weekday:'short', day:'numeric', month:'short', year:'numeric' })

7. All error messages, toast notifications, and validation text must be in the active language.

8. Arabic text must have lineHeight set to fontSize * 1.8 minimum. Arabic script needs this space.

9. Text alignment: textAlign:'right' in Arabic mode, textAlign:'left' in English mode.
   Apply via a shared style helper: getTextAlign(lang) => lang === 'ar' ? 'right' : 'left'

10. Swipe actions on cards: in RTL, swipe from right-to-left to reveal actions (matching iOS RTL convention).

================================================================================
DESIGN SYSTEM
================================================================================

Define constants in mobile/src/theme/colors.ts:

  BACKGROUND_DARK:    '#0F0F14'
  BACKGROUND_LIGHT:   '#F8F7FC'
  SURFACE_DARK:       '#1A1A26'
  SURFACE_LIGHT:      '#FFFFFF'
  BORDER_DARK:        'rgba(255,255,255,0.08)'
  BORDER_LIGHT:       'rgba(0,0,0,0.07)'
  ACCENT:             '#7C6DFA'   <- primary brand, indigo
  DANGER:             '#FA6D8A'   <- urgent / renewing soon
  SUCCESS:            '#10B981'   <- confirmed / high confidence
  WARNING:            '#FAC06D'   <- trial ending / within 7 days
  TEXT_PRIMARY_DARK:  '#E8E8F0'
  TEXT_PRIMARY_LIGHT: '#14141A'
  TEXT_MUTED_DARK:    '#7A7A9A'
  TEXT_MUTED_LIGHT:   '#8A8AAA'

Define in mobile/src/theme/typography.ts:
  H1: { fontSize: 28, fontWeight: '700' }
  H2: { fontSize: 22, fontWeight: '600' }
  H3: { fontSize: 18, fontWeight: '600' }
  BODY: { fontSize: 15, fontWeight: '400' }
  CAPTION: { fontSize: 12, fontWeight: '400' }
  Arabic lineHeight multiplier: 1.8

SPACING scale: 4, 8, 12, 16, 20, 24, 32, 48 (multiples of 4)
CARD: borderRadius:14, padding:16, shadowOpacity:0.08 (iOS), elevation:2 (Android)
INPUT: height:52, borderRadius:12, paddingHorizontal:16, borderWidth:1

================================================================================
i18n DICTIONARY â€” mobile/src/i18n/index.ts
================================================================================

Create a LanguageContext (React Context) that exposes:
  { language: 'ar' | 'en', setLanguage, t: (key: string, vars?: Record<string,string>) => string }

The t() function replaces {placeholders} in strings with vars values.

Full dictionary:

const translations = {
  ar: {
    app_name: 'Ø±Ø§Ø¯Ø§Ø± Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª',
    login: 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„',
    signup: 'Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨',
    email: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ',
    password: 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±',
    forgot_password: 'Ù†Ø³ÙŠØª ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±ØŸ',
    get_started: 'Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¢Ù†',
    skip: 'ØªØ®Ø·ÙŠ',
    next: 'Ø§Ù„ØªØ§Ù„ÙŠ',
    connect_gmail: 'Ø±Ø¨Ø· Gmail',
    disconnect_gmail: 'Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„',
    gmail_connected: 'Gmail Ù…ØªØµÙ„',
    gmail_disconnected: 'Gmail ØºÙŠØ± Ù…ÙØ¹Ù‘Ù„ â€” Ø§Ø¶ØºØ· Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø±Ø¨Ø·',
    reconnect_gmail: 'Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø¨Ø· Gmail',
    dashboard: 'Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…',
    renewing_this_week: 'ØªØ¬Ø¯Ø¯ Ù‡Ø°Ø§ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹',
    trials_ending: 'ØªØ¬Ø§Ø±Ø¨ ØªÙ†ØªÙ‡ÙŠ Ù‚Ø±ÙŠØ¨Ø§Ù‹',
    next_30_days: 'Ø®Ù„Ø§Ù„ 30 ÙŠÙˆÙ…',
    show_all: 'Ø¹Ø±Ø¶ Ø§Ù„ÙƒÙ„',
    monthly_total: 'Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø´Ù‡Ø±ÙŠ',
    monthly_suffix: '/Ø´Ù‡Ø±',
    active_subscriptions: 'Ø§Ø´ØªØ±Ø§ÙƒØ§Øª Ù†Ø´Ø·Ø©',
    mute: 'ÙƒØªÙ…',
    muted_badge: 'Ù…ÙƒØªÙˆÙ…',
    cancel_sub: 'Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ',
    refresh: 'ØªØ­Ø¯ÙŠØ«',
    edit_amount: 'ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø¨Ù„Øº',
    save: 'Ø­ÙØ¸',
    settings: 'Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª',
    account: 'Ø§Ù„Ø­Ø³Ø§Ø¨',
    language: 'Ø§Ù„Ù„ØºØ©',
    arabic: 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
    english: 'English',
    theme: 'Ø§Ù„Ù…Ø¸Ù‡Ø±',
    theme_dark: 'Ø¯Ø§ÙƒÙ†',
    theme_light: 'ÙØ§ØªØ­',
    theme_auto: 'ØªÙ„Ù‚Ø§Ø¦ÙŠ',
    notifications: 'Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª',
    enable_notifications: 'ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª',
    notify_before: 'Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡ Ù‚Ø¨Ù„ Ø§Ù„ØªØ¬Ø¯ÙŠØ¯',
    one_day: 'ÙŠÙˆÙ… ÙˆØ§Ø­Ø¯',
    three_days: '3 Ø£ÙŠØ§Ù…',
    one_week: 'Ø£Ø³Ø¨ÙˆØ¹',
    privacy_section: 'Ø§Ù„Ø®ØµÙˆØµÙŠØ©',
    privacy_policy: 'Ø³ÙŠØ§Ø³Ø© Ø§Ù„Ø®ØµÙˆØµÙŠØ©',
    delete_account: 'Ø­Ø°Ù Ø§Ù„Ø­Ø³Ø§Ø¨ ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',
    delete_confirm: 'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ØŸ Ø³ÙŠØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹ ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹.',
    delete_confirm_btn: 'Ù†Ø¹Ù…ØŒ Ø§Ø­Ø°Ù Ø­Ø³Ø§Ø¨ÙŠ',
    cancel: 'Ø¥Ù„ØºØ§Ø¡',
    logout: 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬',
    syncing: 'Ø¬Ø§Ø±ÙŠ ÙØ­Øµ Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ...',
    sync_complete: 'Ø§ÙƒØªÙ…Ù„ Ø§Ù„ÙØ­Øµ',
    scanning_last_90: 'ØªØ­Ù„ÙŠÙ„ Ø¢Ø®Ø± 90 ÙŠÙˆÙ…Ø§Ù‹',
    emails_scanned: '{count} Ø¥ÙŠÙ…ÙŠÙ„ ØªÙ… ÙØ­ØµÙ‡',
    found_subscriptions: 'ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {count} Ø§Ø´ØªØ±Ø§Ùƒ',
    no_subscriptions: 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø§Ø´ØªØ±Ø§ÙƒØ§Øª Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†',
    no_renewals_week: 'Ù„Ø§ ØªØ¬Ø¯ÙŠØ¯Ø§Øª Ù‡Ø°Ø§ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ âœ“',
    no_trials: 'Ù„Ø§ ØªØ¬Ø§Ø±Ø¨ Ù†Ø´Ø·Ø©',
    amount_unknown: 'Ù…Ø¨Ù„Øº ØºÙŠØ± Ù…Ø­Ø¯Ø¯',
    amount_display: '{amount} Ø±ÙŠØ§Ù„',
    per_month: '/Ø´Ù‡Ø±',
    days_left: 'Ø¨Ø¹Ø¯ {days} Ø£ÙŠØ§Ù…',
    renews_today: 'ÙŠØ¬Ø¯Ø¯ Ø§Ù„ÙŠÙˆÙ…',
    renews_tomorrow: 'ÙŠØ¬Ø¯Ø¯ ØºØ¯Ø§Ù‹',
    high_confidence: 'Ø«Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©',
    medium_confidence: 'Ø«Ù‚Ø© Ù…ØªÙˆØ³Ø·Ø©',
    low_confidence: 'Ø«Ù‚Ø© Ù…Ù†Ø®ÙØ¶Ø©',
    confidence_high_desc: 'Ø±ØµØ¯Ù†Ø§ Ù‡Ø°Ø§ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ø«Ù‚Ø© Ø¹Ø§Ù„ÙŠØ© Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ',
    confidence_mid_desc: 'Ø±ØµØ¯Ù†Ø§ Ù‡Ø°Ø§ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„ÙƒÙ† ØªØ£ÙƒØ¯ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ',
    subscription_detail: 'ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ',
    source_email: 'Ù…ØµØ¯Ø± Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„',
    category: 'Ø§Ù„ÙØ¦Ø©',
    renewal_date: 'ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØ¬Ø¯ÙŠØ¯',
    hijri_date: 'Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù‡Ø¬Ø±ÙŠ',
    trial_badge: 'ØªØ¬Ø±Ø¨Ø© Ù…Ø¬Ø§Ù†ÙŠØ©',
    coming_soon: 'Ù‚Ø±ÙŠØ¨Ø§Ù‹',
    permission_title: 'Ù„Ù…Ø§Ø°Ø§ Ù†Ø­ØªØ§Ø¬ ØµÙ„Ø§Ø­ÙŠØ© GmailØŸ',
    permission_body: 'Ø³Ù†Ù‚Ø±Ø£ Ø¥ÙŠÙ…ÙŠÙ„Ø§ØªÙƒ Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª ÙÙ‚Ø·. Ù„Ù† Ù†Ø®Ø²Ù† Ù…Ø­ØªÙˆÙ‰ Ø¥ÙŠÙ…ÙŠÙ„Ø§ØªÙƒ â€” Ù†Ø®Ø²Ù† ÙÙ‚Ø· Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬Ø© Ù…Ø«Ù„ Ø§Ø³Ù… Ø§Ù„Ø®Ø¯Ù…Ø© ÙˆØªØ§Ø±ÙŠØ® Ø§Ù„ØªØ¬Ø¯ÙŠØ¯.',
    permission_access_1: 'Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„Ø§Øª Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª',
    permission_access_2: 'ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© ÙÙ‚Ø· (Ù„Ø§ Ø¥Ø±Ø³Ø§Ù„ØŒ Ù„Ø§ Ø­Ø°Ù)',
    permission_denied: 'ÙŠØ­ØªØ§Ø¬ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© Ù„Ù„Ø¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­.',
    skip_for_now: 'ØªØ®Ø·ÙŠ Ø§Ù„Ø¢Ù†',
    retry: 'Ø­Ø§ÙˆÙ„ Ù…Ø¬Ø¯Ø¯Ø§Ù‹',
    error_generic: 'Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø¬Ø¯Ø¯Ø§Ù‹',
    error_invalid_email: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ­ÙŠØ­',
    error_weak_password: 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„',
    error_wrong_credentials: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©',
    error_passwords_match: 'ÙƒÙ„Ù…ØªØ§ Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚ØªÙŠÙ†',
    reset_sent: 'ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø¥Ù„Ù‰ Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ',
    action_success: 'ØªÙ… Ø¨Ù†Ø¬Ø§Ø­',
    onboard_1_title: 'Ø±Ø§Ø¯Ø§Ø± Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª',
    onboard_1_body: 'Ù†ÙƒØªØ´Ù Ø§Ø´ØªØ±Ø§ÙƒØ§ØªÙƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø¯ÙˆÙ† Ø£ÙŠ Ø¬Ù‡Ø¯ Ù…Ù†Ùƒ',
    onboard_2_title: 'ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ù‚Ø¨Ù„ Ø§Ù„ØªØ¬Ø¯ÙŠØ¯',
    onboard_2_body: 'Ù†ÙØ°ÙƒÙ‘Ø±Ùƒ Ù‚Ø¨Ù„ Ø£ÙŠ ØªØ¬Ø¯ÙŠØ¯ Ø­ØªÙ‰ Ù„Ø§ ØªÙÙØ§Ø¬Ø£ Ø¨Ø±Ø³ÙˆÙ… ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø©',
    onboard_3_title: 'ØªØ­ÙƒÙ… ÙƒØ§Ù…Ù„',
    onboard_3_body: 'Ø£Ù„ØºÙ Ø£Ùˆ Ø£Ø®ÙÙ Ù…Ø§ ØªØ±ÙŠØ¯ â€” Ø£Ù†Øª Ù…Ù† ÙŠÙ‚Ø±Ø±',
    cat_streaming: 'Ø¨Ø« Ù…Ø¨Ø§Ø´Ø±',
    cat_software: 'Ø¨Ø±Ù…Ø¬ÙŠØ§Øª',
    cat_food: 'Ø·Ø¹Ø§Ù…',
    cat_finance: 'Ù…Ø§Ù„ÙŠØ©',
    cat_telecom: 'Ø§ØªØµØ§Ù„Ø§Øª',
    cat_cloud: 'Ø³Ø­Ø§Ø¨ÙŠØ©',
    cat_other: 'Ø£Ø®Ø±Ù‰',
    notification_title: 'ØªØ¬Ø¯ÙŠØ¯ Ø§Ø´ØªØ±Ø§Ùƒ {merchant}',
    notification_body_amount: '{title} ÙŠØ¬Ø¯Ø¯ {when} - {amount} Ø±ÙŠØ§Ù„',
    notification_body_no_amount: '{title} ÙŠØ¬Ø¯Ø¯ {when}',
  },
  en: {
    app_name: 'Subscriptions Radar',
    login: 'Log In',
    signup: 'Create Account',
    email: 'Email Address',
    password: 'Password',
    forgot_password: 'Forgot Password?',
    get_started: 'Get Started',
    skip: 'Skip',
    next: 'Next',
    connect_gmail: 'Connect Gmail',
    disconnect_gmail: 'Disconnect Gmail',
    gmail_connected: 'Gmail Connected',
    gmail_disconnected: 'Gmail disconnected â€” tap to reconnect',
    reconnect_gmail: 'Reconnect Gmail',
    dashboard: 'Dashboard',
    renewing_this_week: 'Renewing This Week',
    trials_ending: 'Trials Ending',
    next_30_days: 'Next 30 Days',
    show_all: 'Show All',
    monthly_total: 'Monthly Total',
    monthly_suffix: '/month',
    active_subscriptions: 'active subscriptions',
    mute: 'Mute',
    muted_badge: 'Muted',
    cancel_sub: 'Mark Canceled',
    refresh: 'Refresh',
    edit_amount: 'Edit Amount',
    save: 'Save',
    settings: 'Settings',
    account: 'Account',
    language: 'Language',
    arabic: 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
    english: 'English',
    theme: 'Theme',
    theme_dark: 'Dark',
    theme_light: 'Light',
    theme_auto: 'Auto',
    notifications: 'Notifications',
    enable_notifications: 'Enable Notifications',
    notify_before: 'Notify me before renewal',
    one_day: '1 day',
    three_days: '3 days',
    one_week: '1 week',
    privacy_section: 'Privacy',
    privacy_policy: 'Privacy Policy',
    delete_account: 'Delete My Account & Data',
    delete_confirm: 'Are you sure? All your data will be permanently deleted and cannot be recovered.',
    delete_confirm_btn: 'Yes, Delete My Account',
    cancel: 'Cancel',
    logout: 'Log Out',
    syncing: 'Scanning your inbox...',
    sync_complete: 'Scan complete',
    scanning_last_90: 'Analyzing last 90 days',
    emails_scanned: '{count} emails scanned',
    found_subscriptions: 'Found {count} subscriptions',
    no_subscriptions: 'No subscriptions found yet',
    no_renewals_week: 'No renewals this week âœ“',
    no_trials: 'No active trials',
    amount_unknown: 'Amount unknown',
    amount_display: 'SAR {amount}',
    per_month: '/month',
    days_left: 'in {days} days',
    renews_today: 'Renews today',
    renews_tomorrow: 'Renews tomorrow',
    high_confidence: 'High confidence',
    medium_confidence: 'Medium confidence',
    low_confidence: 'Low confidence',
    confidence_high_desc: 'We detected this subscription with high confidence from your inbox',
    confidence_mid_desc: 'We detected this subscription but verify with your inbox to be sure',
    subscription_detail: 'Subscription Detail',
    source_email: 'Source Email',
    category: 'Category',
    renewal_date: 'Renewal Date',
    hijri_date: 'Hijri Date',
    trial_badge: 'Free Trial',
    coming_soon: 'Coming Soon',
    permission_title: 'Why we need Gmail access',
    permission_body: 'We read your emails to find subscriptions only. We do not store your email content â€” only extracted subscription info like service name and renewal date.',
    permission_access_1: 'Read emails to detect subscriptions',
    permission_access_2: 'Read-only access (cannot send or delete)',
    permission_denied: 'The app needs read permission to work correctly.',
    skip_for_now: 'Skip for now',
    retry: 'Try Again',
    error_generic: 'Something went wrong, please try again',
    error_invalid_email: 'Invalid email address',
    error_weak_password: 'Password must be at least 6 characters',
    error_wrong_credentials: 'Incorrect email or password',
    error_passwords_match: 'Passwords do not match',
    reset_sent: 'A recovery link has been sent to your email',
    action_success: 'Done',
    onboard_1_title: 'Subscriptions Radar',
    onboard_1_body: 'We automatically detect your subscriptions from your inbox with zero effort',
    onboard_2_title: 'Renewal Alerts',
    onboard_2_body: 'We remind you before any renewal so you are never surprised by charges',
    onboard_3_title: 'Full Control',
    onboard_3_body: 'Mute or cancel anything â€” you decide what matters',
    cat_streaming: 'Streaming',
    cat_software: 'Software',
    cat_food: 'Food',
    cat_finance: 'Finance',
    cat_telecom: 'Telecom',
    cat_cloud: 'Cloud',
    cat_other: 'Other',
    notification_title: 'Subscription Renewal: {merchant}',
    notification_body_amount: '{title} renews {when} â€” SAR {amount}',
    notification_body_no_amount: '{title} renews {when}',
  }
}

================================================================================
ALL 8 SCREENS
================================================================================

---
SCREEN 1: SPLASH
File: mobile/src/screens/SplashScreen.tsx
---

Layout: full screen BACKGROUND_DARK, centered content.

Visual: a "radar" icon â€” 3 concentric circles drawn with SVG or View borders, ACCENT color.
Animate the circles pulsing outward using react-native-reanimated:
  withRepeat(withSequence(withTiming(1.1, {duration:600}), withTiming(1.0, {duration:600})), 2, false)
Below icon: app name text t('app_name') in H1 style.

On mount (useEffect):
  1. Wait minimum 1500ms (to ensure animation plays)
  2. Check supabase.auth.getSession()
  3. If valid session:
     a. Query gmail_accounts table for this user_id
     b. If row exists â†’ navigate replace to 'Dashboard'
     c. If no row â†’ navigate replace to 'ConnectGmail'
  4. If no session:
     a. Read AsyncStorage.getItem('onboarding_complete')
     b. If null or 'false' â†’ navigate replace to 'Onboarding'
     c. If 'true' â†’ navigate replace to 'Auth'

---
SCREEN 2: ONBOARDING
File: mobile/src/screens/OnboardingScreen.tsx
---

State: currentSlide (0, 1, 2)

Three slides, rendered as a horizontal FlatList with pagingEnabled=true and scrollEnabled=false
(programmatic navigation only using scrollToIndex).

Slide 0:
  - Icon: radar SVG (3 concentric circles) 80x80, ACCENT color, with pulse animation
  - Title: t('onboard_1_title'), H1, centered
  - Body: t('onboard_1_body'), BODY, centered, TEXT_MUTED color, maxWidth:280

Slide 1:
  - Icon: bell SVG or Ionicons 'notifications' at 80px, DANGER color
  - Title: t('onboard_2_title')
  - Body: t('onboard_2_body')

Slide 2:
  - Icon: checkmark inside circle SVG or Ionicons 'shield-checkmark' at 80px, SUCCESS color
  - Title: t('onboard_3_title')
  - Body: t('onboard_3_body')

Bottom bar (fixed, not scrolling):
  - Row of 3 dots: filled ACCENT for active, BORDER_DARK for inactive, width:8, height:8, borderRadius:4
  - On slides 0 and 1: button labeled t('next') â†’ increment currentSlide
  - On slide 2: button labeled t('get_started') â†’ AsyncStorage.setItem('onboarding_complete','true') â†’ navigate to 'Auth'
  - "Skip" text button top trailing corner â†’ same action as get_started

---
SCREEN 3: AUTH
File: mobile/src/screens/AuthScreen.tsx
---

State: activeTab ('login' | 'signup'), email, password, confirmPassword, loading, error

Header: small app icon 36x36 + app name, centered at top.

Tab bar: two pressable tabs side by side.
  [t('login')] [t('signup')]
  Active tab: bold text, 2px bottom border in ACCENT color.
  Inactive: TEXT_MUTED.

Fields (all TextInput):
  - Email: keyboardType='email-address', autoCapitalize='none', textAlign from getTextAlign(lang)
  - Password: secureTextEntry=true, textAlign from getTextAlign(lang)
  - Confirm Password: only visible on signup tab, secureTextEntry=true

Below password field (login tab only):
  Text button: t('forgot_password'), TEXT_MUTED, 13px
  On press: if email is empty show inline error; else call supabase.auth.resetPasswordForEmail(email)
  Show success toast: t('reset_sent')

Inline validation (show below relevant field, DANGER color, 12px):
  - Email: must match email regex
  - Password: min 6 chars
  - Confirm Password: must match password (signup only)

Primary CTA button: full width, ACCENT background, 52px height, borderRadius 12.
  Login: t('login') â†’ supabase.auth.signInWithPassword
  Signup: t('signup') â†’ supabase.auth.signUp, then create user_preferences row with { language:'ar', defaults }

On success:
  - Query gmail_accounts for this user_id
  - If found â†’ navigate replace to 'Dashboard'
  - Else â†’ navigate replace to 'ConnectGmail'

---
SCREEN 4: CONNECT GMAIL
File: mobile/src/screens/ConnectGmailScreen.tsx
---

No navigation tabs shown. Full-screen layout.

Top area (centered):
  - Gmail "G" logo (official multicolor: #4285F4 / #34A853 / #FBBC05 / #EA4335) 56x56
  - Title: t('permission_title'), H2, centered, maxWidth:300
  - Body card:
    Background: SURFACE_DARK, borderRadius:12, padding:16, margin:24
    Text: t('permission_body'), BODY, TEXT_MUTED, lineHeight:24
  - Two permission bullets below the card:
    Each: bullet dot ACCENT + text (t('permission_access_1'), t('permission_access_2'))

Connect button:
  White background, 1px BORDER_DARK border, borderRadius:12, height:52
  Left side: Google G logo 20x20
  Text: t('connect_gmail'), dark text
  On press: start Google OAuth flow with expo-auth-session
    config = AuthSession.makeRedirectUri({ useProxy:true })
    request = useAuthRequest({ clientId: EXPO_PUBLIC_GOOGLE_CLIENT_ID, scopes: ['https://www.googleapis.com/auth/gmail.readonly'], redirectUri })
    On result.type === 'success':
      POST to EXPO_PUBLIC_API_BASE_URL + '/oauth/google' with body { user_id, code: result.params.code, redirect_uri }
      On HTTP 200 â†’ navigate replace to 'SyncProgress'
    On result.type === 'error' or 'dismiss':
      Show error card: t('permission_denied') + retry button

Skip text link below button: t('skip_for_now')
  On press: AsyncStorage.setItem('gmail_skipped','true') â†’ navigate replace to 'Dashboard'

---
SCREEN 5: SYNC PROGRESS
File: mobile/src/screens/SyncProgressScreen.tsx
---

No tabs. Full screen. Centered layout.

Radar animation:
  3 View circles, each with borderWidth:2, borderColor:ACCENT, borderRadius:9999
  Sizes: 80, 140, 200
  Each animates: withRepeat(withDelay(index*300, withSequence(withTiming({opacity:0.8, scale:1}, ...), withTiming({opacity:0, scale:1.3}, ...))), -1)
  This creates a ripple effect where rings fade out as they expand.

Text below:
  - t('syncing'), H3, TEXT_PRIMARY, centered
  - t('scanning_last_90'), BODY, TEXT_MUTED, centered, marginTop:8

Progress bar:
  Background track: SURFACE_DARK, height:4, borderRadius:2, width:'80%', marginTop:24
  Fill: ACCENT background, height:4, borderRadius:2
  Fill width: animated from 0 to (done/total * 100)%

Beneath bar:
  Text: t('emails_scanned').replace('{count}', done) updated from poll

On mount:
  1. Trigger POST /gmail/sync (with X-CRON-KEY from env â€” note: for dev testing, this is okay)
     Better: the server should auto-trigger after /oauth/google completes. Either approach is fine.
  2. Start polling GET /gmail/status?user_id=X every 2000ms
  3. Update progress bar and count text from poll response

When is_complete=true OR after 45 seconds:
  1. Stop polling
  2. Show large Ionicons 'checkmark-circle' in SUCCESS color, 80px, fade in
  3. Show t('sync_complete') + '\n' + t('found_subscriptions').replace('{count}', done)
  4. After 2000ms â†’ navigate replace to 'Dashboard'

---
SCREEN 6: DASHBOARD
File: mobile/src/screens/DashboardScreen.tsx
---

Root: SafeAreaView + ScrollView with refreshControl (pull-to-refresh).
Pull-to-refresh: triggers fetchSubscriptions() and optionally re-pings /gmail/sync.

HEADER ROW:
  Leading side (right in RTL): Text t('app_name'), H2, bold
  Trailing side (left in RTL): TouchableOpacity with user avatar circle (40x40, ACCENT background, first letter of email)
  On avatar press: navigate to 'Settings'

GMAIL DISCONNECTED BANNER (conditional):
  Show when: no gmail_accounts row for user, OR last_sync_at is null, OR last_sync_at older than 48 hours
  Style: WARNING background with 0.15 opacity, borderLeft:3px solid WARNING, padding:12, borderRadius:10, marginBottom:12
  Row: warning icon (Ionicons 'warning') + Text t('gmail_disconnected') + Ionicons chevron
  On press: navigate to 'ConnectGmail'
  Show dismiss X button on right â€” hides banner for current session only (useState)

MONTHLY TOTAL CARD:
  Background: LinearGradient from 'rgba(124,109,250,0.2)' to 'rgba(250,109,138,0.15)'
  Border: 1px solid 'rgba(124,109,250,0.3)', borderRadius:16, padding:20
  Primary text (animated count-up using react-native-reanimated):
    Arabic: "{total_sar.toLocaleString('ar-SA')} Ø±ÙŠØ§Ù„" + t('monthly_suffix')
    English: "SAR {total_sar}" + t('monthly_suffix')
    If no SAR amounts known: show "â€” Ø±ÙŠØ§Ù„" + small caption "Ø£Ø¶Ù Ø§Ù„Ù…Ø¨Ø§Ù„Øº ÙŠØ¯ÙˆÙŠØ§Ù‹ / Add amounts manually"
  Secondary text: "{active_count} " + t('active_subscriptions'), TEXT_MUTED, 13px
  If any subscription renews in < 7 days: sub-row with DANGER color: "X " + t('renewing_this_week')

SECTION COMPONENT (reusable):
  Props: title, dotColor, items, emptyText, showViewAll (bool), onViewAll
  Header row: colored dot (8x8 circle) + title text (bold, 15px) + count badge (ACCENT/15 background, 11px)
  Items: map to <SubscriptionCard />
  Empty state: ghost card (dashed border, BORDER_DARK, borderRadius:12, padding:20, centered text TEXT_MUTED)

3 SECTIONS:

Section 1 â€” t('renewing_this_week'):
  dotColor: DANGER
  Filter subscriptions: renewal_date within next 7 days, status='active', confidence>=0.70
  Sort by renewal_date ascending

Section 2 â€” t('trials_ending'):
  dotColor: WARNING
  Filter: is_trial=true AND renewal_date within next 14 days, status='active'

Section 3 â€” t('next_30_days'):
  dotColor: ACCENT
  Filter: renewal_date between 8 and 30 days from now, status='active'
  Show first 3 items only, with "Show All" expand toggle if more than 3

SUBSCRIPTION CARD â€” mobile/src/components/SubscriptionCard.tsx
Props: subscription, onMute, onCancel, onPress

Outer container: TouchableOpacity, SURFACE_DARK background, borderRadius:14,
  marginBottom:8, overflow:'hidden'
  On press: navigate to 'SubscriptionDetail' with subscription param

Inner row (flexDirection:'row', padding:14, alignItems:'center', gap:12):
  RTL-aware: in AR mode, use flexDirection:'row-reverse'

  LEADING (merchant logo area, 40x40):
    If merchant logo URL available (future): <Image>
    Fallback: View with background color based on hash of merchant name, borderRadius:10
      Center: merchant name first letter, white, bold, 18px

  MIDDLE (flex:1):
    Merchant name: bold, 16px, TEXT_PRIMARY, textAlign from getTextAlign
    Renewal date: 13px, color based on urgency (see rules), textAlign from getTextAlign
      < 1 day â†’ DANGER, t('renews_today')
      1 day â†’ DANGER, t('renews_tomorrow')
      < 3 days â†’ DANGER, t('days_left').replace('{days}', N)
      < 7 days â†’ WARNING, t('days_left').replace('{days}', N)
      else â†’ TEXT_MUTED, t('days_left').replace('{days}', N)
    If is_trial=true: small pill badge below date, WARNING background, t('trial_badge'), 11px

  TRAILING (amount + confidence):
    Amount badge: if amount_sar_override OR amount_sar exists:
      small pill, ACCENT/15 background, ACCENT text, 12px bold
      Arabic: "{amount.toLocaleString('ar-SA')} Ø±ÙŠØ§Ù„" / English: "SAR {amount}"
    Else: "â€“" in TEXT_MUTED

BELOW THE ROW: thin confidence bar, 3px height, no padding
  width: (confidence * 100)%, borderRadius on right side (or left in RTL)
  â‰¥ 0.85: SUCCESS color
  0.70â€“0.84: WARNING color

SWIPE ACTIONS (use a simple gesture approach or a lightweight swipe library):
  Swipe reveals two buttons:
  [ğŸ”‡ t('mute')] â€” WARNING background, white text
  [âœ— t('cancel_sub')] â€” DANGER background, white text
  On mute: call POST /subscriptions/mute, update local state to filter out or show muted
  On cancel: call POST /subscriptions/cancel, remove from list with fade animation

MUTED subscriptions: show with opacity:0.45, append t('muted_badge') small pill after merchant name

SKELETON STATE:
  While subscriptions are loading (isLoading=true):
  Show 3 skeleton cards: same dimensions as real card, SURFACE_DARK background,
  inner shapes are BORDER_DARK rectangles, animated with opacity cycling 0.4â†’0.7â†’0.4 using react-native-reanimated withRepeat

FLOATING ACTION BUTTON:
  Position: absolute, bottom:24, trailing:24 (right in LTR, left in RTL)
  Size: 56x56, borderRadius:28, ACCENT background, elevation:4
  Icon: Ionicons 'add' 28px white
  On press: show Toast/Snackbar with t('coming_soon')

---
SCREEN 7: SUBSCRIPTION DETAIL
File: mobile/src/screens/SubscriptionDetailScreen.tsx
---

Receives navigation param: subscription (full subscription object)

HEADER: navigation back button (RTL-aware icon) + title t('subscription_detail')

SCROLL CONTENT:

  Merchant logo: 64x64, borderRadius:18, centered
    Same fallback colored-initial circle logic as card.

  Merchant name: H2, centered, marginTop:12
  Category badge: small pill, SURFACE_DARK, borderRadius:20, paddingHorizontal:12, paddingVertical:4
    Show localized category: t('cat_' + subscription.category)
  Trial badge (if is_trial): WARNING/20 background, WARNING text, t('trial_badge')

  INFO ROWS (styled list):
  Each row: flexDirection row-reverse in RTL, justifyContent:'space-between', paddingVertical:12,
    borderBottomWidth:1, borderBottomColor:BORDER_DARK

    Row 1: t('renewal_date') | formatted date in active language
    Row 2: t('hijri_date') | Hijri date string (only show in AR mode, or always show as extra info)
    Row 3: "Ø§Ù„Ù…Ø¨Ù„Øº / Amount" | amount_sar_override OR amount_sar formatted, or t('amount_unknown')
    Row 4: "Ø§Ù„Ø«Ù‚Ø© / Confidence" | thin bar + label

  CONFIDENCE SECTION:
    SURFACE_DARK card, borderRadius:10, padding:14, marginTop:16
    Confidence percentage text: bold, 20px, ACCENT color: (confidence * 100).toFixed(0) + '%'
    Label: t('high_confidence') / t('medium_confidence') / t('low_confidence')
    Description: t('confidence_high_desc') or t('confidence_mid_desc'), TEXT_MUTED, 13px

  SOURCE EMAIL SNIPPET:
    Label: t('source_email'), bold, 13px, marginTop:16
    Card: SURFACE_DARK, borderRadius:10, padding:12
    Text: email snippet (first 150 chars), italic, TEXT_MUTED, 13px, lineHeight:20

  ACTION BUTTONS (2x2 grid, gap:10, marginTop:20):
    [ğŸ”‡ t('mute')] SURFACE_DARK with BORDER_DARK border, borderRadius:10, height:48
      On press: POST /subscriptions/mute â†’ show toast t('action_success') â†’ pop navigation

    [âœ— t('cancel_sub')] SURFACE_DARK with DANGER/30 border, DANGER text, borderRadius:10, height:48
      On press: confirm Alert â†’ POST /subscriptions/cancel â†’ pop navigation

    [âœï¸ t('edit_amount')] SURFACE_DARK, borderRadius:10, height:48
      On press: show Modal with numeric TextInput (keyboardType='decimal-pad')
        Label: "Ø±ÙŠØ§Ù„ / SAR", placeholder current amount
        Save button â†’ POST /subscriptions/update-amount â†’ update local state â†’ close modal

    [ğŸ”„ t('refresh')] SURFACE_DARK, borderRadius:10, height:48
      On press: show ActivityIndicator in button â†’ POST /subscriptions/refresh â†’ hide loader â†’ toast

---
SCREEN 8: SETTINGS
File: mobile/src/screens/SettingsScreen.tsx
---

Accessed from dashboard header avatar tap. NavigationHeader with back button + title t('settings').

ScrollView with sections. Each section: label above (TEXT_MUTED, 12px, uppercase, letterSpacing:1)
followed by a card (SURFACE_DARK, borderRadius:14) with rows separated by thin borders.

SECTION t('account'):
  Row: user email display, TEXT_MUTED
  Row: t('logout'), DANGER color, on press: Alert confirm â†’ supabase.auth.signOut() â†’ AsyncStorage.clear() â†’ navigate replace to 'Auth'

SECTION t('app') (label "Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ / App"):
  Row: t('language')
    Right side: segmented control [Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© | English]
    On change: AsyncStorage.setItem('lang', newLang) â†’ update LanguageContext
    Show Alert: "Ø³ÙŠØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØºÙŠÙŠØ± ÙÙˆØ±Ø§Ù‹ / Change applied. Restart for full effect."
    Call I18nManager.forceRTL(newLang === 'ar')

  Row: t('theme')
    Right side: segmented control [t('theme_dark') | t('theme_light') | t('theme_auto')]
    On change: AsyncStorage.setItem('theme', newTheme) â†’ update ThemeContext

SECTION t('notifications'):
  Row: t('enable_notifications')
    Right side: Switch component, value from user_preferences.notify_enabled
    On toggle on: call Notifications.requestPermissionsAsync()
      If granted: save to user_preferences, schedule notifications
      If denied: show Alert explaining how to enable in system settings
    On toggle off: cancel all scheduled notifications

  Row: t('notify_before') â€” only visible if notifications enabled
    Right side: segmented control [t('one_day') | t('three_days') | t('one_week')]
    On change: save to user_preferences.notify_days_before â†’ reschedule notifications

SECTION "Gmail":
  Row: show connected email from gmail_accounts row, or "ØºÙŠØ± Ù…ØªØµÙ„ / Not connected" in TEXT_MUTED
  Row: t('disconnect_gmail'), DANGER color
    On press: Alert confirm â†’ supabase DELETE gmail_accounts WHERE user_id â†’ navigate to 'ConnectGmail'

SECTION t('privacy_section'):
  Row: t('privacy_policy') with trailing arrow â†’ Linking.openURL('https://yourapp.com/privacy')
  Row: t('delete_account'), DANGER color
    On press: Alert with t('delete_confirm'), buttons [t('cancel'), t('delete_confirm_btn')]
    On confirm: POST /account/delete with Bearer JWT
      On success: supabase.auth.signOut() â†’ AsyncStorage.clear() â†’ navigate replace to 'Onboarding'

================================================================================
DATABASE SCHEMA â€” /supabase/migrations/001_initial.sql
================================================================================

CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE gmail_accounts (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  refresh_token_encrypted TEXT NOT NULL,
  last_sync_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE gmail_accounts ENABLE ROW LEVEL SECURITY;
CREATE POLICY "own_gmail" ON gmail_accounts FOR ALL USING (auth.uid() = user_id);

CREATE TABLE emails_raw (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  gmail_message_id TEXT NOT NULL,
  thread_id TEXT,
  from_email TEXT,
  subject TEXT,
  snippet TEXT,
  body_text TEXT,
  internal_date TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, gmail_message_id)
);
ALTER TABLE emails_raw ENABLE ROW LEVEL SECURITY;
CREATE POLICY "own_emails" ON emails_raw FOR ALL USING (auth.uid() = user_id);
CREATE INDEX idx_emails_raw_user_date ON emails_raw(user_id, internal_date DESC);

CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  merchant TEXT NOT NULL,
  title TEXT NOT NULL,
  category TEXT DEFAULT 'other' CHECK (category IN ('streaming','software','food','finance','telecom','cloud','other')),
  renewal_date TIMESTAMPTZ,
  amount_sar NUMERIC,
  amount_sar_override NUMERIC,
  is_trial BOOLEAN DEFAULT FALSE,
  confidence REAL NOT NULL,
  status TEXT DEFAULT 'active' CHECK (status IN ('active','muted','canceled')),
  notify_days_before INT DEFAULT 3,
  source TEXT DEFAULT 'gmail',
  source_message_id TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, merchant, renewal_date, amount_sar)
);
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "own_subs" ON subscriptions FOR ALL USING (auth.uid() = user_id);
CREATE INDEX idx_subs_user_renewal ON subscriptions(user_id, renewal_date);
CREATE INDEX idx_subs_user_status ON subscriptions(user_id, status);

CREATE TABLE processing_queue (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  gmail_message_id TEXT NOT NULL,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending','processing','done','error')),
  attempts INT DEFAULT 0,
  last_error TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE processing_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "own_queue" ON processing_queue FOR ALL USING (auth.uid() = user_id);
CREATE INDEX idx_queue_status ON processing_queue(status, created_at);

CREATE TABLE user_preferences (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  language TEXT DEFAULT 'ar' CHECK (language IN ('ar','en')),
  theme TEXT DEFAULT 'dark' CHECK (theme IN ('dark','light','auto')),
  notify_enabled BOOLEAN DEFAULT TRUE,
  notify_days_before INT DEFAULT 3,
  onboarding_complete BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "own_prefs" ON user_preferences FOR ALL USING (auth.uid() = user_id);

================================================================================
BACKEND â€” /server
================================================================================

ENV VARS in server/.env:
  SUPABASE_URL=
  SUPABASE_SERVICE_ROLE_KEY=
  GOOGLE_CLIENT_ID=
  GOOGLE_CLIENT_SECRET=
  OPENAI_API_KEY=
  BACKEND_ENCRYPTION_KEY=    # 64 hex chars (32 bytes) â€” generate with: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
  CRON_SECRET_KEY=            # any strong random string
  PORT=3000

FILE STRUCTURE:
  server/src/
  â”œâ”€â”€ index.ts
  â”œâ”€â”€ middleware/
  â”‚   â”œâ”€â”€ cronAuth.ts         <- checks req.headers['x-cron-key'] === CRON_SECRET_KEY
  â”‚   â””â”€â”€ userAuth.ts         <- verifies Bearer JWT via supabase.auth.getUser(token), attaches userId to req
  â”œâ”€â”€ lib/
  â”‚   â”œâ”€â”€ supabase.ts         <- createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)
  â”‚   â”œâ”€â”€ crypto.ts           <- AES-256-CBC encrypt/decrypt
  â”‚   â”œâ”€â”€ gmail.ts            <- getOAuthClient, fetchMessageList, fetchMessageBody
  â”‚   â””â”€â”€ openai.ts           <- extractSubscription(emailData) returns parsed JSON
  â””â”€â”€ routes/
      â”œâ”€â”€ oauth.ts
      â”œâ”€â”€ gmail.ts
      â”œâ”€â”€ queue.ts
      â”œâ”€â”€ subscriptions.ts
      â””â”€â”€ account.ts

CRYPTO (server/src/lib/crypto.ts):

  export function encrypt(text: string): string {
    const iv = crypto.randomBytes(16)
    const key = Buffer.from(process.env.BACKEND_ENCRYPTION_KEY!, 'hex')
    const cipher = crypto.createCipheriv('aes-256-cbc', key, iv)
    const encrypted = Buffer.concat([cipher.update(text, 'utf8'), cipher.final()])
    return iv.toString('hex') + ':' + encrypted.toString('hex')
  }

  export function decrypt(ciphertext: string): string {
    const [ivHex, encHex] = ciphertext.split(':')
    const key = Buffer.from(process.env.BACKEND_ENCRYPTION_KEY!, 'hex')
    const decipher = crypto.createDecipheriv('aes-256-cbc', key, Buffer.from(ivHex, 'hex'))
    return Buffer.concat([decipher.update(Buffer.from(encHex, 'hex')), decipher.final()]).toString('utf8')
  }

POST /oauth/google:
  No auth middleware.
  Zod schema: { user_id: z.string().uuid(), code: z.string(), redirect_uri: z.string().url() }
  1. new google.auth.OAuth2(CLIENT_ID, CLIENT_SECRET, redirect_uri)
  2. const { tokens } = await oauth2Client.getToken(code)
  3. oauth2Client.setCredentials(tokens)
  4. const gmail = google.gmail({ version:'v1', auth: oauth2Client })
  5. const profile = await gmail.users.getProfile({ userId:'me' })
  6. const encryptedToken = encrypt(tokens.refresh_token!)
  7. Upsert gmail_accounts: { user_id, email: profile.data.emailAddress, refresh_token_encrypted: encryptedToken }
     ON CONFLICT (user_id) DO UPDATE SET refresh_token_encrypted=..., email=..., updated_at=NOW()
  8. Return JSON: { success: true, email: profile.data.emailAddress }

GET /gmail/status:
  Middleware: userAuth
  Query param: user_id (must equal JWT user_id)
  1. Count processing_queue rows for this user grouped by status
  2. Fetch gmail_accounts.last_sync_at
  3. Return: { total, done, pending, errors, is_complete: (pending === 0 && total > 0), last_sync_at }

POST /gmail/sync:
  Middleware: cronAuth
  Zod body: { user_id: z.string().uuid() }
  1. Fetch gmail_accounts row, decrypt token
  2. Create oauth2Client, setCredentials({ refresh_token })
  3. Build query string:
     - last_sync_at null â†’ 'newer_than:90d'
     - else â†’ 'after:' + Math.floor(new Date(last_sync_at).getTime() / 1000)
  4. Call gmail.users.messages.list({ userId:'me', q, maxResults:500 })
  5. Handle pagination (nextPageToken) to get all results
  6. For each message.id not already in emails_raw (check with SELECT):
     a. gmail.users.messages.get({ userId:'me', id, format:'metadata', metadataHeaders:['From','Subject','Date'] })
     b. INSERT INTO emails_raw (user_id, gmail_message_id, thread_id, from_email, subject, snippet, internal_date)
        on conflict do nothing
     c. INSERT INTO processing_queue (user_id, gmail_message_id, status:'pending')
        on conflict do nothing
  7. UPDATE gmail_accounts SET last_sync_at=NOW()
  8. Return: { queued_count: N }

POST /process/queue:
  Middleware: cronAuth
  Zod body: { limit: z.number().min(1).max(50).default(20) }
  1. SELECT id, user_id, gmail_message_id FROM processing_queue
     WHERE status='pending' ORDER BY created_at ASC LIMIT limit
  2. For each item:
     a. UPDATE status='processing', attempts=attempts+1, updated_at=NOW()
     b. Get emails_raw row for this gmail_message_id
     c. If body_text is null:
        - Get user's refresh_token from gmail_accounts, decrypt
        - Fetch gmail.users.messages.get({ userId:'me', id, format:'full' })
        - Decode base64url email parts recursively (look for text/plain mime type)
        - UPDATE emails_raw SET body_text=decodedText
     d. Strip HTML: text.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim().slice(0, 2000)
     e. Call openai.extractSubscription({ from_email, subject, body_text, today: new Date().toISOString() })
     f. Parse JSON response
     g. If result.confidence >= 0.70 OR result.is_trial === true:
        INSERT INTO subscriptions (user_id, merchant, title, category, renewal_date, amount_sar, is_trial, confidence, source_message_id)
        VALUES (...)
        ON CONFLICT (user_id, merchant, renewal_date, amount_sar) DO UPDATE
          SET confidence=GREATEST(excluded.confidence, subscriptions.confidence), updated_at=NOW()
     h. UPDATE processing_queue SET status='done', updated_at=NOW()
     i. On any error:
        - attempts >= 3 â†’ status='error', last_error=err.message
        - else â†’ status='pending'
  3. Return: { processed, succeeded, failed }

OPENAI EXTRACTION (server/src/lib/openai.ts):
  Use model: 'gpt-4o-mini'
  System message:
    "You are a subscription detection assistant for Saudi Arabian users.
    Analyze the email and determine if it relates to a subscription, recurring charge, or free trial.
    Respond ONLY with valid JSON. No markdown, no explanation."

  User message:
    "From: {from_email}
    Subject: {subject}
    Body: {body_text}
    Today: {today}

    Return this JSON:
    {
      \"merchant\": \"service or company name, or null\",
      \"title\": \"short title, Arabic if email is in Arabic, English otherwise, max 60 chars\",
      \"summary\": \"one sentence in same language as title\",
      \"category\": \"streaming|software|food|finance|telecom|cloud|other\",
      \"renewal_date\": \"YYYY-MM-DDTHH:MM:SSZ or null\",
      \"amount_sar\": null or number,
      \"is_trial\": boolean,
      \"confidence\": 0.0 to 1.0
    }
    Rules:
    - confidence >= 0.85: clearly a billing, renewal, or subscription email
    - confidence 0.70â€“0.84: probably a subscription but with some uncertainty
    - confidence < 0.70: not a subscription (newsletter, promo, etc.)
    - amount_sar must be null UNLESS email explicitly states an amount in SAR or Ø±ÙŠØ§Ù„
    - is_trial = true if email mentions trial, ØªØ¬Ø±Ø¨Ø©, Ù…Ø¬Ø§Ù†ÙŠ Ù„Ù…Ø¯Ø©, ØªØ¬Ø±ÙŠØ¨ÙŠ, free period
    - merchant = null if this is not a subscription-related email"

  Parse with JSON.parse(). On failure: return { confidence: 0, merchant: null, title: '', summary: '', category: 'other', renewal_date: null, amount_sar: null, is_trial: false }

POST /subscriptions/mute:
  Middleware: userAuth
  Zod: { subscription_id: z.string().uuid() }
  UPDATE subscriptions SET status='muted', updated_at=NOW()
  WHERE id=subscription_id AND user_id=req.userId
  Return: { success: true }

POST /subscriptions/cancel:
  Middleware: userAuth
  Zod: { subscription_id: z.string().uuid() }
  UPDATE subscriptions SET status='canceled', updated_at=NOW()
  WHERE id=subscription_id AND user_id=req.userId
  Return: { success: true }

POST /subscriptions/update-amount:
  Middleware: userAuth
  Zod: { subscription_id: z.string().uuid(), amount_sar: z.number().positive() }
  UPDATE subscriptions SET amount_sar_override=amount_sar, updated_at=NOW()
  WHERE id=subscription_id AND user_id=req.userId
  Return: { success: true }

POST /subscriptions/refresh:
  Middleware: userAuth
  Zod: { subscription_id: z.string().uuid() }
  1. SELECT source_message_id from subscriptions WHERE id=... AND user_id=...
  2. UPDATE processing_queue SET status='pending', attempts=0, updated_at=NOW()
     WHERE gmail_message_id=source_message_id AND user_id=req.userId
     If no row, INSERT new row
  Return: { success: true }

POST /account/delete:
  Middleware: userAuth
  1. SELECT refresh_token_encrypted from gmail_accounts WHERE user_id=req.userId
  2. If found: try to decrypt and call Google's revoke endpoint (https://oauth2.googleapis.com/revoke?token=...)
     Ignore errors from revoke step.
  3. DELETE FROM processing_queue WHERE user_id=req.userId
  4. DELETE FROM emails_raw WHERE user_id=req.userId
  5. DELETE FROM subscriptions WHERE user_id=req.userId
  6. DELETE FROM gmail_accounts WHERE user_id=req.userId
  7. DELETE FROM user_preferences WHERE user_id=req.userId
  8. await supabase.auth.admin.deleteUser(req.userId)
  Return: { success: true }

================================================================================
NOTIFICATIONS â€” mobile/src/lib/notifications.ts
================================================================================

import * as Notifications from 'expo-notifications'

Notifications.setNotificationHandler({
  handleNotification: async () => ({ shouldShowAlert:true, shouldPlaySound:true, shouldSetBadge:false })
})

export async function scheduleRenewalNotifications(subscriptions, lang, notifyDaysBefore) {
  await Notifications.cancelAllScheduledNotificationsAsync()
  const now = new Date()
  for (const sub of subscriptions) {
    if (!sub.renewal_date || sub.status !== 'active') continue
    const renewalDate = new Date(sub.renewal_date)
    const triggerDate = new Date(renewalDate.getTime() - notifyDaysBefore * 24 * 60 * 60 * 1000)
    if (triggerDate <= now) continue
    const daysUntil = Math.ceil((renewalDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24))
    const when = daysUntil === 1 ? (lang==='ar' ? 'ØºØ¯Ø§Ù‹' : 'tomorrow') : (lang==='ar' ? `Ø¨Ø¹Ø¯ ${daysUntil} Ø£ÙŠØ§Ù…` : `in ${daysUntil} days`)
    const amount = sub.amount_sar_override ?? sub.amount_sar
    const bodyKey = amount ? 'notification_body_amount' : 'notification_body_no_amount'
    // build title and body using t() with sub data
    await Notifications.scheduleNotificationAsync({
      content: {
        title: lang==='ar' ? `ØªØ¬Ø¯ÙŠØ¯ Ø§Ø´ØªØ±Ø§Ùƒ ${sub.merchant}` : `Renewal: ${sub.merchant}`,
        body: amount
          ? (lang==='ar' ? `${sub.title} ÙŠØ¬Ø¯Ø¯ ${when} - ${amount} Ø±ÙŠØ§Ù„` : `${sub.title} renews ${when} â€” SAR ${amount}`)
          : (lang==='ar' ? `${sub.title} ÙŠØ¬Ø¯Ø¯ ${when}` : `${sub.title} renews ${when}`),
        data: { subscription_id: sub.id },
      },
      trigger: { date: triggerDate },
    })
  }
}

On notification tap (add in App.tsx):
  Notifications.addNotificationResponseReceivedListener(response => {
    const { subscription_id } = response.notification.request.content.data
    if (subscription_id) {
      navigationRef.navigate('SubscriptionDetail', { subscription_id })
    }
  })

================================================================================
MOBILE ENV VARS â€” mobile/.env
================================================================================

EXPO_PUBLIC_SUPABASE_URL=
EXPO_PUBLIC_SUPABASE_ANON_KEY=
EXPO_PUBLIC_API_BASE_URL=         # e.g. https://your-server.replit.dev
EXPO_PUBLIC_GOOGLE_CLIENT_ID=     # iOS OAuth 2.0 client ID from Google Cloud Console

================================================================================
SECURITY
================================================================================

- NEVER put SUPABASE_SERVICE_ROLE_KEY or BACKEND_ENCRYPTION_KEY in mobile code or mobile .env
- Mobile app uses only SUPABASE_ANON_KEY + user JWTs from Supabase Auth
- /gmail/sync and /process/queue must return 401 if X-CRON-KEY header is missing or wrong
- /subscriptions/* and /account/delete must validate Bearer JWT and confirm ownership (user_id from JWT must match row user_id)
- Always AES-256-CBC encrypt refresh tokens before storing â€” never store plaintext tokens
- Zod validates every request body â€” reject with 400 on invalid input
- Sanitize and truncate email body to 2000 chars before sending to OpenAI
- RLS enforced at database level for all mobile queries (anon key + JWT)

================================================================================
APP STORE SAFETY
================================================================================

- Gmail readonly scope ONLY. No write, send, delete, or compose scopes.
- Permission explainer screen shown BEFORE OAuth consent starts (Screen 4).
- Account deletion fully implemented via POST /account/delete (Apple App Store requirement).
- "Delete My Account & Data" is clearly visible in Settings.
- No SMS, iMessage, WhatsApp, push notification provider, or background location access.
- Notification permission requested only when user opts in from Settings, never on first launch.

================================================================================
BUILD ORDER
================================================================================

Build in this sequence so you always have a runnable state at each step:

1.  supabase/migrations/001_initial.sql â€” all tables, RLS, indexes
2.  server/ â€” Express setup, health check GET /, crypto lib, Supabase client
3.  server/ â€” POST /oauth/google
4.  server/ â€” GET /gmail/status + POST /gmail/sync
5.  server/ â€” POST /process/queue with OpenAI extraction
6.  server/ â€” POST /subscriptions/* + POST /account/delete
7.  mobile/ â€” Expo project init, navigation structure, theme + i18n system, Supabase client
8.  mobile/ â€” SplashScreen + OnboardingScreen
9.  mobile/ â€” AuthScreen with Supabase login/signup
10. mobile/ â€” ConnectGmailScreen with expo-auth-session OAuth
11. mobile/ â€” SyncProgressScreen with polling
12. mobile/ â€” DashboardScreen with real data + SubscriptionCard component
13. mobile/ â€” SubscriptionDetailScreen with all actions
14. mobile/ â€” SettingsScreen
15. mobile/ â€” Notifications scheduling wired to settings
16. README.md
17. End-to-end test: register â†’ connect Gmail â†’ sync â†’ subscriptions appear â†’ mute one â†’ delete account

================================================================================
README.md â€” REQUIRED SECTIONS
================================================================================

1. Prerequisites: Node 18+, Expo CLI (npm i -g expo-cli), EAS CLI (optional for builds)
2. Supabase setup:
   a. Create project at supabase.com
   b. Open SQL Editor, paste and run supabase/migrations/001_initial.sql
   c. Copy: Project URL, anon key (for mobile), service role key (for server)
3. Google Cloud Console setup:
   a. Create new project
   b. Enable "Gmail API" in API Library
   c. Create OAuth 2.0 credentials â†’ Application type: iOS
   d. Add authorized redirect URI: https://auth.expo.io/@YOUR_EXPO_USERNAME/subscriptions-radar
   e. Copy the Client ID
4. Generate secrets:
   BACKEND_ENCRYPTION_KEY: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
   CRON_SECRET_KEY: node -e "console.log(require('crypto').randomBytes(24).toString('hex'))"
5. Fill in mobile/.env and server/.env with all values
6. Install dependencies:
   cd server && npm install
   cd ../mobile && npm install
7. Run backend: cd server && npm run dev (starts on PORT 3000)
8. Run mobile: cd mobile && npx expo start
9. Test on iPhone: scan QR code with Expo Go app
10. Trigger sync manually for testing:
    curl -X POST http://localhost:3000/gmail/sync \
      -H "X-CRON-KEY: YOUR_CRON_SECRET" \
      -H "Content-Type: application/json" \
      -d '{"user_id":"YOUR_USER_UUID"}'
11. Trigger queue processing:
    curl -X POST http://localhost:3000/process/queue \
      -H "X-CRON-KEY: YOUR_CRON_SECRET" \
      -H "Content-Type: application/json" \
      -d '{"limit":20}'
